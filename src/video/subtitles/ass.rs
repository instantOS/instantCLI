//! ASS (Advanced SubStation Alpha) file format generation.
//!
//! Generates ASS subtitle files for burning into video with FFmpeg.

use std::fmt::Write;
use std::time::Duration;

use super::remap::RemappedSubtitle;

/// Style configuration for ASS subtitles.
#[derive(Debug, Clone)]
pub struct AssStyle {
    /// Style name
    pub name: String,
    /// Font name
    pub font_name: String,
    /// Font size in pixels
    pub font_size: u32,
    /// Primary color in ABGR format (e.g., &H00FFFFFF for white)
    pub primary_color: String,
    /// Outline color in ABGR format
    pub outline_color: String,
    /// Background/shadow color in ABGR format
    pub back_color: String,
    /// Bold (-1 = true, 0 = false)
    pub bold: bool,
    /// Outline width in pixels
    pub outline: u32,
    /// Shadow depth in pixels
    pub shadow: u32,
    /// Alignment (numpad layout: 1-3=bottom, 4-6=mid, 7-9=top)
    pub alignment: u8,
    /// Left margin in pixels
    pub margin_l: u32,
    /// Right margin in pixels
    pub margin_r: u32,
    /// Vertical margin in pixels (distance from bottom for bottom-aligned)
    pub margin_v: u32,
}

impl Default for AssStyle {
    fn default() -> Self {
        Self {
            name: "Default".to_string(),
            font_name: "Arial".to_string(),
            font_size: 56,
            primary_color: "&H00FFFFFF".to_string(), // White
            outline_color: "&H00000000".to_string(), // Black
            back_color: "&H80000000".to_string(),    // Semi-transparent black
            bold: true,
            outline: 3,
            shadow: 2,
            alignment: 2, // Bottom-center
            margin_l: 40,
            margin_r: 40,
            margin_v: 150, // 150px from bottom edge for reels
        }
    }
}

impl AssStyle {
    /// Create a style optimized for reels mode (9:16 vertical video).
    pub fn for_reels() -> Self {
        Self::default()
    }

    /// Format the style line for the ASS file.
    fn to_style_line(&self) -> String {
        let bold_val = if self.bold { -1 } else { 0 };
        format!(
            "Style: {name},{font},{size},{primary},&H000000FF,{outline},{back},{bold},0,0,0,100,100,0,0,1,{outline_w},{shadow},{align},{ml},{mr},{mv},1",
            name = self.name,
            font = self.font_name,
            size = self.font_size,
            primary = self.primary_color,
            outline = self.outline_color,
            back = self.back_color,
            bold = bold_val,
            outline_w = self.outline,
            shadow = self.shadow,
            align = self.alignment,
            ml = self.margin_l,
            mr = self.margin_r,
            mv = self.margin_v,
        )
    }
}

/// Generate an ASS subtitle file content.
///
/// # Arguments
/// * `subtitles` - List of remapped subtitles with final timeline timing
/// * `style` - Style configuration for the subtitles
/// * `play_res` - Resolution tuple (width, height) matching output video
///
/// # Returns
/// The complete ASS file content as a string.
pub fn generate_ass_file(
    subtitles: &[RemappedSubtitle],
    style: &AssStyle,
    play_res: (u32, u32),
) -> String {
    let mut output = String::new();

    // Script Info section
    writeln!(output, "[Script Info]").unwrap();
    writeln!(output, "; Generated by instantCLI").unwrap();
    writeln!(output, "ScriptType: v4.00+").unwrap();
    writeln!(output, "PlayResX: {}", play_res.0).unwrap();
    writeln!(output, "PlayResY: {}", play_res.1).unwrap();
    writeln!(output, "WrapStyle: 0").unwrap();
    writeln!(output, "ScaledBorderAndShadow: yes").unwrap();
    writeln!(output).unwrap();

    // V4+ Styles section
    writeln!(output, "[V4+ Styles]").unwrap();
    writeln!(
        output,
        "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding"
    )
    .unwrap();
    writeln!(output, "{}", style.to_style_line()).unwrap();
    writeln!(output).unwrap();

    // Events section
    writeln!(output, "[Events]").unwrap();
    writeln!(
        output,
        "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text"
    )
    .unwrap();

    for subtitle in subtitles {
        let start = format_ass_timestamp(subtitle.start);
        let end = format_ass_timestamp(subtitle.end);
        let text = escape_ass_text(&subtitle.text);

        writeln!(
            output,
            "Dialogue: 0,{start},{end},{style},,0,0,0,,{text}",
            start = start,
            end = end,
            style = style.name,
            text = text
        )
        .unwrap();
    }

    output
}

/// Format a Duration as an ASS timestamp (H:MM:SS.cc).
fn format_ass_timestamp(duration: Duration) -> String {
    let total_secs = duration.as_secs_f64();
    let hours = (total_secs / 3600.0).floor() as u32;
    let minutes = ((total_secs % 3600.0) / 60.0).floor() as u32;
    let seconds = (total_secs % 60.0).floor() as u32;
    let centiseconds = ((total_secs % 1.0) * 100.0).round() as u32;

    format!(
        "{}:{:02}:{:02}.{:02}",
        hours, minutes, seconds, centiseconds
    )
}

/// Escape special characters in ASS text.
fn escape_ass_text(text: &str) -> String {
    text.replace('\\', "\\\\")
        .replace('{', "\\{")
        .replace('}', "\\}")
        .replace('\n', "\\N")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_format_ass_timestamp() {
        assert_eq!(format_ass_timestamp(Duration::from_secs(0)), "0:00:00.00");
        assert_eq!(
            format_ass_timestamp(Duration::from_millis(1500)),
            "0:00:01.50"
        );
        assert_eq!(
            format_ass_timestamp(Duration::from_secs(61)),
            "0:01:01.00"
        );
        assert_eq!(
            format_ass_timestamp(Duration::from_secs(3661)),
            "1:01:01.00"
        );
        assert_eq!(
            format_ass_timestamp(Duration::from_millis(125)),
            "0:00:00.13"
        ); // Rounds to nearest centisecond
    }

    #[test]
    fn test_escape_ass_text() {
        assert_eq!(escape_ass_text("Hello world"), "Hello world");
        assert_eq!(escape_ass_text("Line1\nLine2"), "Line1\\NLine2");
        assert_eq!(escape_ass_text("{override}"), "\\{override\\}");
        assert_eq!(escape_ass_text("path\\to\\file"), "path\\\\to\\\\file");
    }

    #[test]
    fn test_generate_ass_file() {
        let subtitles = vec![
            RemappedSubtitle {
                start: Duration::from_secs(0),
                end: Duration::from_millis(2500),
                text: "Hello world".to_string(),
            },
            RemappedSubtitle {
                start: Duration::from_millis(3000),
                end: Duration::from_millis(5000),
                text: "Second line".to_string(),
            },
        ];

        let style = AssStyle::for_reels();
        let output = generate_ass_file(&subtitles, &style, (1080, 1920));

        assert!(output.contains("[Script Info]"));
        assert!(output.contains("PlayResX: 1080"));
        assert!(output.contains("PlayResY: 1920"));
        assert!(output.contains("[V4+ Styles]"));
        assert!(output.contains("[Events]"));
        assert!(output.contains("Dialogue: 0,0:00:00.00,0:00:02.50,Default,,0,0,0,,Hello world"));
        assert!(output.contains("Dialogue: 0,0:00:03.00,0:00:05.00,Default,,0,0,0,,Second line"));
    }

    #[test]
    fn test_style_line() {
        let style = AssStyle::for_reels();
        let line = style.to_style_line();

        assert!(line.starts_with("Style: Default,Arial,56,"));
        assert!(line.contains(",2,")); // Alignment = 2
        assert!(line.contains(",150,")); // MarginV = 150
    }
}
